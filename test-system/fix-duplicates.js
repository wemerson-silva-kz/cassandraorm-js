// Corre√ß√£o de Duplicatas usando Schema - CassandraORM JS v1.0.1
import { createClient, uuid } from 'cassandraorm-js';

console.log('üîß CORRE√á√ÉO DE DUPLICATAS - CASSANDRAORM JS v1.0.1');

let client;

// Schema com valida√ß√£o √∫nica para email
const userSchemaUnique = {
  fields: {
    id: 'uuid',
    email: 'text',
    name: 'text',
    created_at: 'timestamp'
  },
  key: ['email'], // Email como chave prim√°ria para garantir unicidade
  options: {
    table_name: 'users_unique'
  }
};

// Schema para posts sem duplicatas
const postSchemaUnique = {
  fields: {
    id: 'timeuuid',
    user_email: 'text', // Usar email ao inv√©s de user_id
    title: 'text',
    content: 'text',
    created_at: 'timestamp'
  },
  key: ['user_email', 'title'], // Combina√ß√£o √∫nica por usu√°rio + t√≠tulo
  options: {
    table_name: 'posts_unique'
  }
};

async function setupClient() {
  try {
    console.log('\nüîß CONFIGURANDO CLIENTE...');
    
    client = createClient({
      clientOptions: {
        contactPoints: ['127.0.0.1'],
        localDataCenter: 'datacenter1',
        keyspace: 'test_system'
      },
      ormOptions: {
        migration: 'safe' // Habilitar cria√ß√£o autom√°tica de tabelas
      }
    });
    
    await client.connect();
    console.log('‚úÖ Cliente conectado');
    
  } catch (error) {
    console.error('‚ùå Erro na configura√ß√£o:', error.message);
    throw error;
  }
}

async function createUniqueSchemas() {
  try {
    console.log('\nüèóÔ∏è CRIANDO SCHEMAS √öNICOS...');
    
    // Carregar schema de usu√°rios √∫nicos
    const UserUnique = await client.loadSchema('users_unique', userSchemaUnique);
    console.log('‚úÖ Schema users_unique criado');
    
    // Carregar schema de posts √∫nicos
    const PostUnique = await client.loadSchema('posts_unique', postSchemaUnique);
    console.log('‚úÖ Schema posts_unique criado');
    
    return { UserUnique, PostUnique };
    
  } catch (error) {
    console.error('‚ùå Erro ao criar schemas:', error.message);
    throw error;
  }
}

async function migrateDuplicateUsers() {
  try {
    console.log('\nüë• MIGRANDO USU√ÅRIOS SEM DUPLICATAS...');
    
    // Buscar todos os usu√°rios da tabela original
    const originalUsers = await client.execute('SELECT id, name, email, created_at FROM users');
    console.log(`üìä Usu√°rios originais: ${originalUsers.rows.length}`);
    
    // Usar Map para eliminar duplicatas por email
    const uniqueUsers = new Map();
    
    originalUsers.rows.forEach(user => {
      if (!uniqueUsers.has(user.email)) {
        uniqueUsers.set(user.email, {
          id: user.id,
          email: user.email,
          name: user.name,
          created_at: user.created_at
        });
      } else {
        console.log(`‚ö†Ô∏è Duplicata ignorada: ${user.name} (${user.email})`);
      }
    });
    
    console.log(`üìä Usu√°rios √∫nicos: ${uniqueUsers.size}`);
    
    // Inserir usu√°rios √∫nicos na nova tabela
    let insertedCount = 0;
    for (const [email, user] of uniqueUsers) {
      try {
        await client.execute(
          'INSERT INTO users_unique (email, id, name, created_at) VALUES (?, ?, ?, ?)',
          [user.email, user.id, user.name, user.created_at]
        );
        insertedCount++;
        console.log(`‚úÖ Migrado: ${user.name} (${user.email})`);
      } catch (error) {
        console.log(`‚ùå Erro ao migrar ${user.email}: ${error.message}`);
      }
    }
    
    console.log(`‚úÖ ${insertedCount} usu√°rios √∫nicos migrados`);
    return uniqueUsers;
    
  } catch (error) {
    console.error('‚ùå Erro na migra√ß√£o de usu√°rios:', error.message);
    throw error;
  }
}

async function migrateDuplicatePosts(uniqueUsers) {
  try {
    console.log('\nüìù MIGRANDO POSTS SEM DUPLICATAS...');
    
    // Buscar todos os posts da tabela original
    const originalPosts = await client.execute('SELECT id, user_id, title, content, created_at FROM posts');
    console.log(`üìä Posts originais: ${originalPosts.rows.length}`);
    
    // Criar mapa de user_id para email
    const userIdToEmail = new Map();
    for (const [email, user] of uniqueUsers) {
      userIdToEmail.set(user.id.toString(), email);
    }
    
    // Usar Set para eliminar duplicatas por user_email + title
    const uniquePosts = new Map();
    
    originalPosts.rows.forEach(post => {
      const userEmail = userIdToEmail.get(post.user_id.toString());
      if (userEmail) {
        const postKey = `${userEmail}:${post.title}`;
        
        if (!uniquePosts.has(postKey)) {
          uniquePosts.set(postKey, {
            id: post.id,
            user_email: userEmail,
            title: post.title,
            content: post.content,
            created_at: post.created_at
          });
        } else {
          console.log(`‚ö†Ô∏è Post duplicado ignorado: "${post.title}" de ${userEmail}`);
        }
      } else {
        console.log(`‚ö†Ô∏è Post √≥rf√£o ignorado: "${post.title}" (user_id n√£o encontrado)`);
      }
    });
    
    console.log(`üìä Posts √∫nicos: ${uniquePosts.size}`);
    
    // Inserir posts √∫nicos na nova tabela
    let insertedCount = 0;
    for (const [postKey, post] of uniquePosts) {
      try {
        await client.execute(
          'INSERT INTO posts_unique (user_email, title, id, content, created_at) VALUES (?, ?, ?, ?, ?)',
          [post.user_email, post.title, post.id, post.content, post.created_at]
        );
        insertedCount++;
        console.log(`‚úÖ Migrado: "${post.title}" de ${post.user_email}`);
      } catch (error) {
        console.log(`‚ùå Erro ao migrar post "${post.title}": ${error.message}`);
      }
    }
    
    console.log(`‚úÖ ${insertedCount} posts √∫nicos migrados`);
    
  } catch (error) {
    console.error('‚ùå Erro na migra√ß√£o de posts:', error.message);
    throw error;
  }
}

async function validateUniqueData() {
  try {
    console.log('\nüîç VALIDANDO DADOS √öNICOS...');
    
    // Verificar usu√°rios √∫nicos
    const uniqueUsersCount = await client.execute('SELECT COUNT(*) FROM users_unique');
    console.log(`üìä Usu√°rios √∫nicos na nova tabela: ${uniqueUsersCount.rows[0].count}`);
    
    // Listar usu√°rios √∫nicos
    const uniqueUsersList = await client.execute('SELECT email, name FROM users_unique');
    console.log('üìã Usu√°rios √∫nicos:');
    uniqueUsersList.rows.forEach((user, i) => {
      console.log(`  ${i + 1}. ${user.name} - ${user.email}`);
    });
    
    // Verificar posts √∫nicos
    const uniquePostsCount = await client.execute('SELECT COUNT(*) FROM posts_unique');
    console.log(`üìä Posts √∫nicos na nova tabela: ${uniquePostsCount.rows[0].count}`);
    
    // Listar posts √∫nicos
    const uniquePostsList = await client.execute('SELECT user_email, title FROM posts_unique');
    console.log('üìã Posts √∫nicos:');
    uniquePostsList.rows.forEach((post, i) => {
      console.log(`  ${i + 1}. "${post.title}" de ${post.user_email}`);
    });
    
  } catch (error) {
    console.error('‚ùå Erro na valida√ß√£o:', error.message);
  }
}

async function testUniqueConstraints() {
  try {
    console.log('\nüîí TESTANDO CONSTRAINTS √öNICOS...');
    
    // Tentar inserir usu√°rio com email duplicado
    try {
      await client.execute(
        'INSERT INTO users_unique (email, id, name, created_at) VALUES (?, ?, ?, ?)',
        ['joao@example.com', uuid(), 'Jo√£o Duplicado', new Date()]
      );
      console.log('‚ùå Email duplicado foi aceito (n√£o deveria)');
    } catch (error) {
      console.log('‚úÖ Email duplicado rejeitado corretamente');
    }
    
    // Tentar inserir post com t√≠tulo duplicado para mesmo usu√°rio
    try {
      await client.execute(
        'INSERT INTO posts_unique (user_email, title, id, content, created_at) VALUES (?, ?, ?, ?, ?)',
        ['joao@example.com', 'Primeiro Post do Jo√£o', uuid(), 'Conte√∫do duplicado', new Date()]
      );
      console.log('‚ùå Post duplicado foi aceito (n√£o deveria)');
    } catch (error) {
      console.log('‚úÖ Post duplicado rejeitado corretamente');
    }
    
  } catch (error) {
    console.error('‚ùå Erro no teste de constraints:', error.message);
  }
}

async function generateReport() {
  try {
    console.log('\nüìã RELAT√ìRIO DE CORRE√á√ÉO DE DUPLICATAS:');
    
    // Contar dados originais
    const originalUsers = await client.execute('SELECT COUNT(*) FROM users');
    const originalPosts = await client.execute('SELECT COUNT(*) FROM posts');
    
    // Contar dados √∫nicos
    const uniqueUsers = await client.execute('SELECT COUNT(*) FROM users_unique');
    const uniquePosts = await client.execute('SELECT COUNT(*) FROM posts_unique');
    
    console.log('üìä ANTES DA CORRE√á√ÉO:');
    console.log(`  - Usu√°rios: ${originalUsers.rows[0].count}`);
    console.log(`  - Posts: ${originalPosts.rows[0].count}`);
    
    console.log('üìä AP√ìS A CORRE√á√ÉO:');
    console.log(`  - Usu√°rios √∫nicos: ${uniqueUsers.rows[0].count}`);
    console.log(`  - Posts √∫nicos: ${uniquePosts.rows[0].count}`);
    
    const usersDuplicatesRemoved = originalUsers.rows[0].count - uniqueUsers.rows[0].count;
    const postsDuplicatesRemoved = originalPosts.rows[0].count - uniquePosts.rows[0].count;
    
    console.log('üîß DUPLICATAS REMOVIDAS:');
    console.log(`  - Usu√°rios duplicados removidos: ${usersDuplicatesRemoved}`);
    console.log(`  - Posts duplicados removidos: ${postsDuplicatesRemoved}`);
    
    if (usersDuplicatesRemoved > 0 || postsDuplicatesRemoved > 0) {
      console.log('‚úÖ DUPLICATAS CORRIGIDAS COM SUCESSO!');
    } else {
      console.log('‚ÑπÔ∏è Nenhuma duplicata foi removida');
    }
    
  } catch (error) {
    console.error('‚ùå Erro no relat√≥rio:', error.message);
  }
}

async function cleanup() {
  try {
    console.log('\nüßπ LIMPEZA...');
    if (client) {
      await client.disconnect();
      console.log('‚úÖ Desconectado');
    }
  } catch (error) {
    console.error('‚ùå Erro na limpeza:', error.message);
  }
}

async function runDuplicateFix() {
  try {
    await setupClient();
    await createUniqueSchemas();
    const uniqueUsers = await migrateDuplicateUsers();
    await migrateDuplicatePosts(uniqueUsers);
    await validateUniqueData();
    await testUniqueConstraints();
    await generateReport();
    
    console.log('\nüéâ CORRE√á√ÉO DE DUPLICATAS CONCLU√çDA!');
    console.log('üìä RESUMO:');
    console.log('  ‚úÖ Schemas √∫nicos criados via loadSchema');
    console.log('  ‚úÖ Usu√°rios migrados sem duplicatas');
    console.log('  ‚úÖ Posts migrados sem duplicatas');
    console.log('  ‚úÖ Constraints √∫nicos validados');
    console.log('  ‚úÖ Dados √∫nicos verificados');
    console.log('\nüîß SISTEMA CORRIGIDO COM SCHEMAS √öNICOS!');
    
  } catch (error) {
    console.error('\nüí• ERRO NA CORRE√á√ÉO:', error.message);
  } finally {
    await cleanup();
  }
}

// Executar corre√ß√£o de duplicatas
runDuplicateFix();
